// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v4.25.3
// source: ws.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ProtoAny } from "./google/protobuf/any";

export const protobufPackage = "ws";

export interface ProtoCursorPaginatedResponse {
  data: ProtoAny[];
  count: number;
  nextCursor?: string | undefined;
}

/** Optional array wrappers */
export interface ProtoStringArray {
  values: string[];
}

export interface ProtoNumberArray {
  values: number[];
}

export interface ProtoBoolArray {
  values: boolean[];
}

/**
 * Represents a single filter value, which can be a single value
 * (string, number, or bool) or optional arrays of each type.
 */
export interface ProtoFilterValue {
  string_value?: string | undefined;
  number_value?: number | undefined;
  bool_value?:
    | boolean
    | undefined;
  /** Optional arrays */
  string_array?: ProtoStringArray | undefined;
  number_array?: ProtoNumberArray | undefined;
  bool_array?: ProtoBoolArray | undefined;
}

/** Wrapper for snapshot response payload */
export interface ProtoCursorPaginatedSnapshotPayload {
  /** The actual data for this snapshot. */
  data:
    | ProtoCursorPaginatedResponse
    | undefined;
  /** Filters applied for this subscription (optional) */
  appliedFilters: { [key: string]: ProtoFilterValue };
}

export interface ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry {
  key: string;
  value: ProtoFilterValue | undefined;
}

/** Wrapper for fetchMore response payload */
export interface ProtoFetchMorePayload {
  paginatedData: ProtoCursorPaginatedResponse | undefined;
  appliedFilters: { [key: string]: ProtoFilterValue };
}

export interface ProtoFetchMorePayload_AppliedFiltersEntry {
  key: string;
  value: ProtoFilterValue | undefined;
}

/** Each item in an update message */
export interface ProtoUpdateItem {
  id: string;
  action: ProtoUpdateItem_Action;
  /** Optional data; only needed for added/updated */
  data:
    | ProtoAny
    | undefined;
  /** Optional version or sequence number used for updates */
  version?: number | undefined;
}

export enum ProtoUpdateItem_Action {
  ADDED = 0,
  UPDATED = 1,
  DELETED = 2,
  UNRECOGNIZED = -1,
}

export function protoUpdateItem_ActionFromJSON(object: any): ProtoUpdateItem_Action {
  switch (object) {
    case 0:
    case "ADDED":
      return ProtoUpdateItem_Action.ADDED;
    case 1:
    case "UPDATED":
      return ProtoUpdateItem_Action.UPDATED;
    case 2:
    case "DELETED":
      return ProtoUpdateItem_Action.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProtoUpdateItem_Action.UNRECOGNIZED;
  }
}

export function protoUpdateItem_ActionToJSON(object: ProtoUpdateItem_Action): string {
  switch (object) {
    case ProtoUpdateItem_Action.ADDED:
      return "ADDED";
    case ProtoUpdateItem_Action.UPDATED:
      return "UPDATED";
    case ProtoUpdateItem_Action.DELETED:
      return "DELETED";
    case ProtoUpdateItem_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Wrapper for update responses */
export interface ProtoUpdatesPayload {
  items: ProtoUpdateItem[];
  appliedFilters: { [key: string]: ProtoFilterValue };
}

export interface ProtoUpdatesPayload_AppliedFiltersEntry {
  key: string;
  value: ProtoFilterValue | undefined;
}

function createBaseProtoCursorPaginatedResponse(): ProtoCursorPaginatedResponse {
  return { data: [], count: 0, nextCursor: undefined };
}

export const ProtoCursorPaginatedResponse: MessageFns<ProtoCursorPaginatedResponse> = {
  encode(message: ProtoCursorPaginatedResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.data) {
      ProtoAny.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    if (message.nextCursor !== undefined) {
      writer.uint32(26).string(message.nextCursor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoCursorPaginatedResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoCursorPaginatedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data.push(ProtoAny.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nextCursor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoCursorPaginatedResponse {
    return {
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => ProtoAny.fromJSON(e)) : [],
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      nextCursor: isSet(object.nextCursor) ? globalThis.String(object.nextCursor) : undefined,
    };
  },

  toJSON(message: ProtoCursorPaginatedResponse): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => ProtoAny.toJSON(e));
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.nextCursor !== undefined) {
      obj.nextCursor = message.nextCursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoCursorPaginatedResponse>, I>>(base?: I): ProtoCursorPaginatedResponse {
    return ProtoCursorPaginatedResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoCursorPaginatedResponse>, I>>(object: I): ProtoCursorPaginatedResponse {
    const message = createBaseProtoCursorPaginatedResponse();
    message.data = object.data?.map((e) => ProtoAny.fromPartial(e)) || [];
    message.count = object.count ?? 0;
    message.nextCursor = object.nextCursor ?? undefined;
    return message;
  },
};

function createBaseProtoStringArray(): ProtoStringArray {
  return { values: [] };
}

export const ProtoStringArray: MessageFns<ProtoStringArray> = {
  encode(message: ProtoStringArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoStringArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoStringArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoStringArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ProtoStringArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoStringArray>, I>>(base?: I): ProtoStringArray {
    return ProtoStringArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoStringArray>, I>>(object: I): ProtoStringArray {
    const message = createBaseProtoStringArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseProtoNumberArray(): ProtoNumberArray {
  return { values: [] };
}

export const ProtoNumberArray: MessageFns<ProtoNumberArray> = {
  encode(message: ProtoNumberArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.double(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoNumberArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoNumberArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 9) {
            message.values.push(reader.double());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.double());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoNumberArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: ProtoNumberArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoNumberArray>, I>>(base?: I): ProtoNumberArray {
    return ProtoNumberArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoNumberArray>, I>>(object: I): ProtoNumberArray {
    const message = createBaseProtoNumberArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseProtoBoolArray(): ProtoBoolArray {
  return { values: [] };
}

export const ProtoBoolArray: MessageFns<ProtoBoolArray> = {
  encode(message: ProtoBoolArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.bool(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoBoolArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoBoolArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.values.push(reader.bool());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.bool());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoBoolArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Boolean(e)) : [],
    };
  },

  toJSON(message: ProtoBoolArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoBoolArray>, I>>(base?: I): ProtoBoolArray {
    return ProtoBoolArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoBoolArray>, I>>(object: I): ProtoBoolArray {
    const message = createBaseProtoBoolArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseProtoFilterValue(): ProtoFilterValue {
  return {
    string_value: undefined,
    number_value: undefined,
    bool_value: undefined,
    string_array: undefined,
    number_array: undefined,
    bool_array: undefined,
  };
}

export const ProtoFilterValue: MessageFns<ProtoFilterValue> = {
  encode(message: ProtoFilterValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.string_value !== undefined) {
      writer.uint32(10).string(message.string_value);
    }
    if (message.number_value !== undefined) {
      writer.uint32(17).double(message.number_value);
    }
    if (message.bool_value !== undefined) {
      writer.uint32(24).bool(message.bool_value);
    }
    if (message.string_array !== undefined) {
      ProtoStringArray.encode(message.string_array, writer.uint32(34).fork()).join();
    }
    if (message.number_array !== undefined) {
      ProtoNumberArray.encode(message.number_array, writer.uint32(42).fork()).join();
    }
    if (message.bool_array !== undefined) {
      ProtoBoolArray.encode(message.bool_array, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoFilterValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoFilterValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.string_value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.number_value = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.bool_value = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.string_array = ProtoStringArray.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.number_array = ProtoNumberArray.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bool_array = ProtoBoolArray.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoFilterValue {
    return {
      string_value: isSet(object.string_value) ? globalThis.String(object.string_value) : undefined,
      number_value: isSet(object.number_value) ? globalThis.Number(object.number_value) : undefined,
      bool_value: isSet(object.bool_value) ? globalThis.Boolean(object.bool_value) : undefined,
      string_array: isSet(object.string_array) ? ProtoStringArray.fromJSON(object.string_array) : undefined,
      number_array: isSet(object.number_array) ? ProtoNumberArray.fromJSON(object.number_array) : undefined,
      bool_array: isSet(object.bool_array) ? ProtoBoolArray.fromJSON(object.bool_array) : undefined,
    };
  },

  toJSON(message: ProtoFilterValue): unknown {
    const obj: any = {};
    if (message.string_value !== undefined) {
      obj.string_value = message.string_value;
    }
    if (message.number_value !== undefined) {
      obj.number_value = message.number_value;
    }
    if (message.bool_value !== undefined) {
      obj.bool_value = message.bool_value;
    }
    if (message.string_array !== undefined) {
      obj.string_array = ProtoStringArray.toJSON(message.string_array);
    }
    if (message.number_array !== undefined) {
      obj.number_array = ProtoNumberArray.toJSON(message.number_array);
    }
    if (message.bool_array !== undefined) {
      obj.bool_array = ProtoBoolArray.toJSON(message.bool_array);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoFilterValue>, I>>(base?: I): ProtoFilterValue {
    return ProtoFilterValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoFilterValue>, I>>(object: I): ProtoFilterValue {
    const message = createBaseProtoFilterValue();
    message.string_value = object.string_value ?? undefined;
    message.number_value = object.number_value ?? undefined;
    message.bool_value = object.bool_value ?? undefined;
    message.string_array = (object.string_array !== undefined && object.string_array !== null)
      ? ProtoStringArray.fromPartial(object.string_array)
      : undefined;
    message.number_array = (object.number_array !== undefined && object.number_array !== null)
      ? ProtoNumberArray.fromPartial(object.number_array)
      : undefined;
    message.bool_array = (object.bool_array !== undefined && object.bool_array !== null)
      ? ProtoBoolArray.fromPartial(object.bool_array)
      : undefined;
    return message;
  },
};

function createBaseProtoCursorPaginatedSnapshotPayload(): ProtoCursorPaginatedSnapshotPayload {
  return { data: undefined, appliedFilters: {} };
}

export const ProtoCursorPaginatedSnapshotPayload: MessageFns<ProtoCursorPaginatedSnapshotPayload> = {
  encode(message: ProtoCursorPaginatedSnapshotPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      ProtoCursorPaginatedResponse.encode(message.data, writer.uint32(10).fork()).join();
    }
    Object.entries(message.appliedFilters).forEach(([key, value]) => {
      ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoCursorPaginatedSnapshotPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoCursorPaginatedSnapshotPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = ProtoCursorPaginatedResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.appliedFilters[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoCursorPaginatedSnapshotPayload {
    return {
      data: isSet(object.data) ? ProtoCursorPaginatedResponse.fromJSON(object.data) : undefined,
      appliedFilters: isObject(object.appliedFilters)
        ? Object.entries(object.appliedFilters).reduce<{ [key: string]: ProtoFilterValue }>((acc, [key, value]) => {
          acc[key] = ProtoFilterValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ProtoCursorPaginatedSnapshotPayload): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = ProtoCursorPaginatedResponse.toJSON(message.data);
    }
    if (message.appliedFilters) {
      const entries = Object.entries(message.appliedFilters);
      if (entries.length > 0) {
        obj.appliedFilters = {};
        entries.forEach(([k, v]) => {
          obj.appliedFilters[k] = ProtoFilterValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoCursorPaginatedSnapshotPayload>, I>>(
    base?: I,
  ): ProtoCursorPaginatedSnapshotPayload {
    return ProtoCursorPaginatedSnapshotPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoCursorPaginatedSnapshotPayload>, I>>(
    object: I,
  ): ProtoCursorPaginatedSnapshotPayload {
    const message = createBaseProtoCursorPaginatedSnapshotPayload();
    message.data = (object.data !== undefined && object.data !== null)
      ? ProtoCursorPaginatedResponse.fromPartial(object.data)
      : undefined;
    message.appliedFilters = Object.entries(object.appliedFilters ?? {}).reduce<{ [key: string]: ProtoFilterValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ProtoFilterValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry(): ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry {
  return { key: "", value: undefined };
}

export const ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry: MessageFns<
  ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry
> = {
  encode(
    message: ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ProtoFilterValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ProtoFilterValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ProtoFilterValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ProtoFilterValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry>, I>>(
    base?: I,
  ): ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry {
    return ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry>, I>>(
    object: I,
  ): ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry {
    const message = createBaseProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ProtoFilterValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseProtoFetchMorePayload(): ProtoFetchMorePayload {
  return { paginatedData: undefined, appliedFilters: {} };
}

export const ProtoFetchMorePayload: MessageFns<ProtoFetchMorePayload> = {
  encode(message: ProtoFetchMorePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paginatedData !== undefined) {
      ProtoCursorPaginatedResponse.encode(message.paginatedData, writer.uint32(10).fork()).join();
    }
    Object.entries(message.appliedFilters).forEach(([key, value]) => {
      ProtoFetchMorePayload_AppliedFiltersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoFetchMorePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoFetchMorePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paginatedData = ProtoCursorPaginatedResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ProtoFetchMorePayload_AppliedFiltersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.appliedFilters[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoFetchMorePayload {
    return {
      paginatedData: isSet(object.paginatedData)
        ? ProtoCursorPaginatedResponse.fromJSON(object.paginatedData)
        : undefined,
      appliedFilters: isObject(object.appliedFilters)
        ? Object.entries(object.appliedFilters).reduce<{ [key: string]: ProtoFilterValue }>((acc, [key, value]) => {
          acc[key] = ProtoFilterValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ProtoFetchMorePayload): unknown {
    const obj: any = {};
    if (message.paginatedData !== undefined) {
      obj.paginatedData = ProtoCursorPaginatedResponse.toJSON(message.paginatedData);
    }
    if (message.appliedFilters) {
      const entries = Object.entries(message.appliedFilters);
      if (entries.length > 0) {
        obj.appliedFilters = {};
        entries.forEach(([k, v]) => {
          obj.appliedFilters[k] = ProtoFilterValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoFetchMorePayload>, I>>(base?: I): ProtoFetchMorePayload {
    return ProtoFetchMorePayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoFetchMorePayload>, I>>(object: I): ProtoFetchMorePayload {
    const message = createBaseProtoFetchMorePayload();
    message.paginatedData = (object.paginatedData !== undefined && object.paginatedData !== null)
      ? ProtoCursorPaginatedResponse.fromPartial(object.paginatedData)
      : undefined;
    message.appliedFilters = Object.entries(object.appliedFilters ?? {}).reduce<{ [key: string]: ProtoFilterValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ProtoFilterValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseProtoFetchMorePayload_AppliedFiltersEntry(): ProtoFetchMorePayload_AppliedFiltersEntry {
  return { key: "", value: undefined };
}

export const ProtoFetchMorePayload_AppliedFiltersEntry: MessageFns<ProtoFetchMorePayload_AppliedFiltersEntry> = {
  encode(message: ProtoFetchMorePayload_AppliedFiltersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ProtoFilterValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoFetchMorePayload_AppliedFiltersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoFetchMorePayload_AppliedFiltersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ProtoFilterValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoFetchMorePayload_AppliedFiltersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ProtoFilterValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ProtoFetchMorePayload_AppliedFiltersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ProtoFilterValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoFetchMorePayload_AppliedFiltersEntry>, I>>(
    base?: I,
  ): ProtoFetchMorePayload_AppliedFiltersEntry {
    return ProtoFetchMorePayload_AppliedFiltersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoFetchMorePayload_AppliedFiltersEntry>, I>>(
    object: I,
  ): ProtoFetchMorePayload_AppliedFiltersEntry {
    const message = createBaseProtoFetchMorePayload_AppliedFiltersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ProtoFilterValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseProtoUpdateItem(): ProtoUpdateItem {
  return { id: "", action: 0, data: undefined, version: undefined };
}

export const ProtoUpdateItem: MessageFns<ProtoUpdateItem> = {
  encode(message: ProtoUpdateItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    if (message.data !== undefined) {
      ProtoAny.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.version !== undefined) {
      writer.uint32(32).int64(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoUpdateItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoUpdateItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = ProtoAny.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoUpdateItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      action: isSet(object.action) ? protoUpdateItem_ActionFromJSON(object.action) : 0,
      data: isSet(object.data) ? ProtoAny.fromJSON(object.data) : undefined,
      version: isSet(object.version) ? globalThis.Number(object.version) : undefined,
    };
  },

  toJSON(message: ProtoUpdateItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.action !== 0) {
      obj.action = protoUpdateItem_ActionToJSON(message.action);
    }
    if (message.data !== undefined) {
      obj.data = ProtoAny.toJSON(message.data);
    }
    if (message.version !== undefined) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoUpdateItem>, I>>(base?: I): ProtoUpdateItem {
    return ProtoUpdateItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoUpdateItem>, I>>(object: I): ProtoUpdateItem {
    const message = createBaseProtoUpdateItem();
    message.id = object.id ?? "";
    message.action = object.action ?? 0;
    message.data = (object.data !== undefined && object.data !== null) ? ProtoAny.fromPartial(object.data) : undefined;
    message.version = object.version ?? undefined;
    return message;
  },
};

function createBaseProtoUpdatesPayload(): ProtoUpdatesPayload {
  return { items: [], appliedFilters: {} };
}

export const ProtoUpdatesPayload: MessageFns<ProtoUpdatesPayload> = {
  encode(message: ProtoUpdatesPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      ProtoUpdateItem.encode(v!, writer.uint32(10).fork()).join();
    }
    Object.entries(message.appliedFilters).forEach(([key, value]) => {
      ProtoUpdatesPayload_AppliedFiltersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoUpdatesPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoUpdatesPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(ProtoUpdateItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ProtoUpdatesPayload_AppliedFiltersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.appliedFilters[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoUpdatesPayload {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => ProtoUpdateItem.fromJSON(e)) : [],
      appliedFilters: isObject(object.appliedFilters)
        ? Object.entries(object.appliedFilters).reduce<{ [key: string]: ProtoFilterValue }>((acc, [key, value]) => {
          acc[key] = ProtoFilterValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ProtoUpdatesPayload): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => ProtoUpdateItem.toJSON(e));
    }
    if (message.appliedFilters) {
      const entries = Object.entries(message.appliedFilters);
      if (entries.length > 0) {
        obj.appliedFilters = {};
        entries.forEach(([k, v]) => {
          obj.appliedFilters[k] = ProtoFilterValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoUpdatesPayload>, I>>(base?: I): ProtoUpdatesPayload {
    return ProtoUpdatesPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoUpdatesPayload>, I>>(object: I): ProtoUpdatesPayload {
    const message = createBaseProtoUpdatesPayload();
    message.items = object.items?.map((e) => ProtoUpdateItem.fromPartial(e)) || [];
    message.appliedFilters = Object.entries(object.appliedFilters ?? {}).reduce<{ [key: string]: ProtoFilterValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ProtoFilterValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseProtoUpdatesPayload_AppliedFiltersEntry(): ProtoUpdatesPayload_AppliedFiltersEntry {
  return { key: "", value: undefined };
}

export const ProtoUpdatesPayload_AppliedFiltersEntry: MessageFns<ProtoUpdatesPayload_AppliedFiltersEntry> = {
  encode(message: ProtoUpdatesPayload_AppliedFiltersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ProtoFilterValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoUpdatesPayload_AppliedFiltersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoUpdatesPayload_AppliedFiltersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ProtoFilterValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoUpdatesPayload_AppliedFiltersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ProtoFilterValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ProtoUpdatesPayload_AppliedFiltersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ProtoFilterValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoUpdatesPayload_AppliedFiltersEntry>, I>>(
    base?: I,
  ): ProtoUpdatesPayload_AppliedFiltersEntry {
    return ProtoUpdatesPayload_AppliedFiltersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoUpdatesPayload_AppliedFiltersEntry>, I>>(
    object: I,
  ): ProtoUpdatesPayload_AppliedFiltersEntry {
    const message = createBaseProtoUpdatesPayload_AppliedFiltersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ProtoFilterValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
