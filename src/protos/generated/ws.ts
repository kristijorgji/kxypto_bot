// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v4.25.3
// source: ws.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ProtoAny } from "./google/protobuf/any";
import { ProtoStruct } from "./google/protobuf/struct";

export const protobufPackage = "ws";

/** Represents the status of a fetch response. */
export enum ProtoFetchStatus {
  /** FETCH_STATUS_UNSPECIFIED - Default fallback (required by proto3) */
  FETCH_STATUS_UNSPECIFIED = 0,
  /** FETCH_STATUS_OK - Successful response */
  FETCH_STATUS_OK = 1,
  /** FETCH_STATUS_ERROR - Generic error */
  FETCH_STATUS_ERROR = 2,
  /** FETCH_STATUS_NOT_FOUND - No data found */
  FETCH_STATUS_NOT_FOUND = 3,
  /** FETCH_STATUS_UNAUTHORIZED - Permission denied / invalid token */
  FETCH_STATUS_UNAUTHORIZED = 4,
  /** FETCH_STATUS_TIMEOUT - Server timeout */
  FETCH_STATUS_TIMEOUT = 5,
  UNRECOGNIZED = -1,
}

export function protoFetchStatusFromJSON(object: any): ProtoFetchStatus {
  switch (object) {
    case 0:
    case "FETCH_STATUS_UNSPECIFIED":
      return ProtoFetchStatus.FETCH_STATUS_UNSPECIFIED;
    case 1:
    case "FETCH_STATUS_OK":
      return ProtoFetchStatus.FETCH_STATUS_OK;
    case 2:
    case "FETCH_STATUS_ERROR":
      return ProtoFetchStatus.FETCH_STATUS_ERROR;
    case 3:
    case "FETCH_STATUS_NOT_FOUND":
      return ProtoFetchStatus.FETCH_STATUS_NOT_FOUND;
    case 4:
    case "FETCH_STATUS_UNAUTHORIZED":
      return ProtoFetchStatus.FETCH_STATUS_UNAUTHORIZED;
    case 5:
    case "FETCH_STATUS_TIMEOUT":
      return ProtoFetchStatus.FETCH_STATUS_TIMEOUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProtoFetchStatus.UNRECOGNIZED;
  }
}

export function protoFetchStatusToJSON(object: ProtoFetchStatus): string {
  switch (object) {
    case ProtoFetchStatus.FETCH_STATUS_UNSPECIFIED:
      return "FETCH_STATUS_UNSPECIFIED";
    case ProtoFetchStatus.FETCH_STATUS_OK:
      return "FETCH_STATUS_OK";
    case ProtoFetchStatus.FETCH_STATUS_ERROR:
      return "FETCH_STATUS_ERROR";
    case ProtoFetchStatus.FETCH_STATUS_NOT_FOUND:
      return "FETCH_STATUS_NOT_FOUND";
    case ProtoFetchStatus.FETCH_STATUS_UNAUTHORIZED:
      return "FETCH_STATUS_UNAUTHORIZED";
    case ProtoFetchStatus.FETCH_STATUS_TIMEOUT:
      return "FETCH_STATUS_TIMEOUT";
    case ProtoFetchStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProtoRpcStatus {
  OK = 0,
  ERROR = 1,
  UNRECOGNIZED = -1,
}

export function protoRpcStatusFromJSON(object: any): ProtoRpcStatus {
  switch (object) {
    case 0:
    case "OK":
      return ProtoRpcStatus.OK;
    case 1:
    case "ERROR":
      return ProtoRpcStatus.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProtoRpcStatus.UNRECOGNIZED;
  }
}

export function protoRpcStatusToJSON(object: ProtoRpcStatus): string {
  switch (object) {
    case ProtoRpcStatus.OK:
      return "OK";
    case ProtoRpcStatus.ERROR:
      return "ERROR";
    case ProtoRpcStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ProtoCursorPaginatedResponse {
  data: ProtoAny[];
  count: number;
  nextCursor?: string | undefined;
}

/** Optional array wrappers */
export interface ProtoStringArray {
  values: string[];
}

export interface ProtoNumberArray {
  values: number[];
}

export interface ProtoBoolArray {
  values: boolean[];
}

/**
 * Represents a single filter value, which can be a single value
 * (string, number, or bool) or optional arrays of each type.
 */
export interface ProtoFilterValue {
  string_value?: string | undefined;
  number_value?: number | undefined;
  bool_value?:
    | boolean
    | undefined;
  /** Optional arrays */
  string_array?: ProtoStringArray | undefined;
  number_array?: ProtoNumberArray | undefined;
  bool_array?: ProtoBoolArray | undefined;
}

/** Wrapper for snapshot response payload */
export interface ProtoCursorPaginatedSnapshotPayload {
  /** The actual data for this snapshot. */
  data:
    | ProtoCursorPaginatedResponse
    | undefined;
  /** Filters applied for this subscription (optional) */
  appliedFilters: { [key: string]: ProtoFilterValue };
}

export interface ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry {
  key: string;
  value: ProtoFilterValue | undefined;
}

/** Wrapper for fetchMore response payload */
export interface ProtoFetchMorePayload {
  paginatedData: ProtoCursorPaginatedResponse | undefined;
  appliedFilters: { [key: string]: ProtoFilterValue };
}

export interface ProtoFetchMorePayload_AppliedFiltersEntry {
  key: string;
  value: ProtoFilterValue | undefined;
}

/**
 * Represents the backend response to a one-time fetch request.
 * Includes a correlation ID, status, and the packed result data.
 */
export interface ProtoFetchResponsePayload {
  requestId: string;
  /** Status code (e.g. "OK", "ERROR", "NOT_FOUND", etc.) */
  status: ProtoFetchStatus;
  /** Human-readable message (useful on errors) */
  message?:
    | string
    | undefined;
  /** The actual data payload, type packed in Any */
  data: ProtoAny | undefined;
}

/** Each item in an update message */
export interface ProtoUpdateItem {
  id: string;
  action: ProtoUpdateItem_Action;
  /** Optional data; only needed for added/updated */
  data:
    | ProtoAny
    | undefined;
  /** Optional version or sequence number used for updates */
  version?: number | undefined;
}

export enum ProtoUpdateItem_Action {
  ADDED = 0,
  UPDATED = 1,
  DELETED = 2,
  UNRECOGNIZED = -1,
}

export function protoUpdateItem_ActionFromJSON(object: any): ProtoUpdateItem_Action {
  switch (object) {
    case 0:
    case "ADDED":
      return ProtoUpdateItem_Action.ADDED;
    case 1:
    case "UPDATED":
      return ProtoUpdateItem_Action.UPDATED;
    case 2:
    case "DELETED":
      return ProtoUpdateItem_Action.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProtoUpdateItem_Action.UNRECOGNIZED;
  }
}

export function protoUpdateItem_ActionToJSON(object: ProtoUpdateItem_Action): string {
  switch (object) {
    case ProtoUpdateItem_Action.ADDED:
      return "ADDED";
    case ProtoUpdateItem_Action.UPDATED:
      return "UPDATED";
    case ProtoUpdateItem_Action.DELETED:
      return "DELETED";
    case ProtoUpdateItem_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Wrapper for update responses */
export interface ProtoUpdatesPayload {
  items: ProtoUpdateItem[];
  appliedFilters: { [key: string]: ProtoFilterValue };
}

export interface ProtoUpdatesPayload_AppliedFiltersEntry {
  key: string;
  value: ProtoFilterValue | undefined;
}

export interface ProtoRpcPayload {
  method: string;
  status: ProtoRpcStatus;
  success?: ProtoRpcSuccessPayload | undefined;
  error?: ProtoRpcErrorPayload | undefined;
}

export interface ProtoRpcSuccessPayload {
  data: ProtoAny | undefined;
}

export interface ProtoRpcErrorPayload {
  errorCode: string;
  errorMessage?: string | undefined;
  details: { [key: string]: any } | undefined;
}

function createBaseProtoCursorPaginatedResponse(): ProtoCursorPaginatedResponse {
  return { data: [], count: 0, nextCursor: undefined };
}

export const ProtoCursorPaginatedResponse: MessageFns<ProtoCursorPaginatedResponse> = {
  encode(message: ProtoCursorPaginatedResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.data) {
      ProtoAny.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    if (message.nextCursor !== undefined) {
      writer.uint32(26).string(message.nextCursor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoCursorPaginatedResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoCursorPaginatedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data.push(ProtoAny.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nextCursor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoCursorPaginatedResponse {
    return {
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => ProtoAny.fromJSON(e)) : [],
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      nextCursor: isSet(object.nextCursor) ? globalThis.String(object.nextCursor) : undefined,
    };
  },

  toJSON(message: ProtoCursorPaginatedResponse): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => ProtoAny.toJSON(e));
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.nextCursor !== undefined) {
      obj.nextCursor = message.nextCursor;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoCursorPaginatedResponse>, I>>(base?: I): ProtoCursorPaginatedResponse {
    return ProtoCursorPaginatedResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoCursorPaginatedResponse>, I>>(object: I): ProtoCursorPaginatedResponse {
    const message = createBaseProtoCursorPaginatedResponse();
    message.data = object.data?.map((e) => ProtoAny.fromPartial(e)) || [];
    message.count = object.count ?? 0;
    message.nextCursor = object.nextCursor ?? undefined;
    return message;
  },
};

function createBaseProtoStringArray(): ProtoStringArray {
  return { values: [] };
}

export const ProtoStringArray: MessageFns<ProtoStringArray> = {
  encode(message: ProtoStringArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoStringArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoStringArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoStringArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ProtoStringArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoStringArray>, I>>(base?: I): ProtoStringArray {
    return ProtoStringArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoStringArray>, I>>(object: I): ProtoStringArray {
    const message = createBaseProtoStringArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseProtoNumberArray(): ProtoNumberArray {
  return { values: [] };
}

export const ProtoNumberArray: MessageFns<ProtoNumberArray> = {
  encode(message: ProtoNumberArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.double(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoNumberArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoNumberArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 9) {
            message.values.push(reader.double());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.double());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoNumberArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: ProtoNumberArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoNumberArray>, I>>(base?: I): ProtoNumberArray {
    return ProtoNumberArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoNumberArray>, I>>(object: I): ProtoNumberArray {
    const message = createBaseProtoNumberArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseProtoBoolArray(): ProtoBoolArray {
  return { values: [] };
}

export const ProtoBoolArray: MessageFns<ProtoBoolArray> = {
  encode(message: ProtoBoolArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.bool(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoBoolArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoBoolArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.values.push(reader.bool());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.bool());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoBoolArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Boolean(e)) : [],
    };
  },

  toJSON(message: ProtoBoolArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoBoolArray>, I>>(base?: I): ProtoBoolArray {
    return ProtoBoolArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoBoolArray>, I>>(object: I): ProtoBoolArray {
    const message = createBaseProtoBoolArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseProtoFilterValue(): ProtoFilterValue {
  return {
    string_value: undefined,
    number_value: undefined,
    bool_value: undefined,
    string_array: undefined,
    number_array: undefined,
    bool_array: undefined,
  };
}

export const ProtoFilterValue: MessageFns<ProtoFilterValue> = {
  encode(message: ProtoFilterValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.string_value !== undefined) {
      writer.uint32(10).string(message.string_value);
    }
    if (message.number_value !== undefined) {
      writer.uint32(17).double(message.number_value);
    }
    if (message.bool_value !== undefined) {
      writer.uint32(24).bool(message.bool_value);
    }
    if (message.string_array !== undefined) {
      ProtoStringArray.encode(message.string_array, writer.uint32(34).fork()).join();
    }
    if (message.number_array !== undefined) {
      ProtoNumberArray.encode(message.number_array, writer.uint32(42).fork()).join();
    }
    if (message.bool_array !== undefined) {
      ProtoBoolArray.encode(message.bool_array, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoFilterValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoFilterValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.string_value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.number_value = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.bool_value = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.string_array = ProtoStringArray.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.number_array = ProtoNumberArray.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bool_array = ProtoBoolArray.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoFilterValue {
    return {
      string_value: isSet(object.string_value) ? globalThis.String(object.string_value) : undefined,
      number_value: isSet(object.number_value) ? globalThis.Number(object.number_value) : undefined,
      bool_value: isSet(object.bool_value) ? globalThis.Boolean(object.bool_value) : undefined,
      string_array: isSet(object.string_array) ? ProtoStringArray.fromJSON(object.string_array) : undefined,
      number_array: isSet(object.number_array) ? ProtoNumberArray.fromJSON(object.number_array) : undefined,
      bool_array: isSet(object.bool_array) ? ProtoBoolArray.fromJSON(object.bool_array) : undefined,
    };
  },

  toJSON(message: ProtoFilterValue): unknown {
    const obj: any = {};
    if (message.string_value !== undefined) {
      obj.string_value = message.string_value;
    }
    if (message.number_value !== undefined) {
      obj.number_value = message.number_value;
    }
    if (message.bool_value !== undefined) {
      obj.bool_value = message.bool_value;
    }
    if (message.string_array !== undefined) {
      obj.string_array = ProtoStringArray.toJSON(message.string_array);
    }
    if (message.number_array !== undefined) {
      obj.number_array = ProtoNumberArray.toJSON(message.number_array);
    }
    if (message.bool_array !== undefined) {
      obj.bool_array = ProtoBoolArray.toJSON(message.bool_array);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoFilterValue>, I>>(base?: I): ProtoFilterValue {
    return ProtoFilterValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoFilterValue>, I>>(object: I): ProtoFilterValue {
    const message = createBaseProtoFilterValue();
    message.string_value = object.string_value ?? undefined;
    message.number_value = object.number_value ?? undefined;
    message.bool_value = object.bool_value ?? undefined;
    message.string_array = (object.string_array !== undefined && object.string_array !== null)
      ? ProtoStringArray.fromPartial(object.string_array)
      : undefined;
    message.number_array = (object.number_array !== undefined && object.number_array !== null)
      ? ProtoNumberArray.fromPartial(object.number_array)
      : undefined;
    message.bool_array = (object.bool_array !== undefined && object.bool_array !== null)
      ? ProtoBoolArray.fromPartial(object.bool_array)
      : undefined;
    return message;
  },
};

function createBaseProtoCursorPaginatedSnapshotPayload(): ProtoCursorPaginatedSnapshotPayload {
  return { data: undefined, appliedFilters: {} };
}

export const ProtoCursorPaginatedSnapshotPayload: MessageFns<ProtoCursorPaginatedSnapshotPayload> = {
  encode(message: ProtoCursorPaginatedSnapshotPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      ProtoCursorPaginatedResponse.encode(message.data, writer.uint32(10).fork()).join();
    }
    Object.entries(message.appliedFilters).forEach(([key, value]) => {
      ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoCursorPaginatedSnapshotPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoCursorPaginatedSnapshotPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = ProtoCursorPaginatedResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.appliedFilters[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoCursorPaginatedSnapshotPayload {
    return {
      data: isSet(object.data) ? ProtoCursorPaginatedResponse.fromJSON(object.data) : undefined,
      appliedFilters: isObject(object.appliedFilters)
        ? Object.entries(object.appliedFilters).reduce<{ [key: string]: ProtoFilterValue }>((acc, [key, value]) => {
          acc[key] = ProtoFilterValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ProtoCursorPaginatedSnapshotPayload): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = ProtoCursorPaginatedResponse.toJSON(message.data);
    }
    if (message.appliedFilters) {
      const entries = Object.entries(message.appliedFilters);
      if (entries.length > 0) {
        obj.appliedFilters = {};
        entries.forEach(([k, v]) => {
          obj.appliedFilters[k] = ProtoFilterValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoCursorPaginatedSnapshotPayload>, I>>(
    base?: I,
  ): ProtoCursorPaginatedSnapshotPayload {
    return ProtoCursorPaginatedSnapshotPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoCursorPaginatedSnapshotPayload>, I>>(
    object: I,
  ): ProtoCursorPaginatedSnapshotPayload {
    const message = createBaseProtoCursorPaginatedSnapshotPayload();
    message.data = (object.data !== undefined && object.data !== null)
      ? ProtoCursorPaginatedResponse.fromPartial(object.data)
      : undefined;
    message.appliedFilters = Object.entries(object.appliedFilters ?? {}).reduce<{ [key: string]: ProtoFilterValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ProtoFilterValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry(): ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry {
  return { key: "", value: undefined };
}

export const ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry: MessageFns<
  ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry
> = {
  encode(
    message: ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ProtoFilterValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ProtoFilterValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ProtoFilterValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ProtoFilterValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry>, I>>(
    base?: I,
  ): ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry {
    return ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry>, I>>(
    object: I,
  ): ProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry {
    const message = createBaseProtoCursorPaginatedSnapshotPayload_AppliedFiltersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ProtoFilterValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseProtoFetchMorePayload(): ProtoFetchMorePayload {
  return { paginatedData: undefined, appliedFilters: {} };
}

export const ProtoFetchMorePayload: MessageFns<ProtoFetchMorePayload> = {
  encode(message: ProtoFetchMorePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paginatedData !== undefined) {
      ProtoCursorPaginatedResponse.encode(message.paginatedData, writer.uint32(10).fork()).join();
    }
    Object.entries(message.appliedFilters).forEach(([key, value]) => {
      ProtoFetchMorePayload_AppliedFiltersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoFetchMorePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoFetchMorePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paginatedData = ProtoCursorPaginatedResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ProtoFetchMorePayload_AppliedFiltersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.appliedFilters[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoFetchMorePayload {
    return {
      paginatedData: isSet(object.paginatedData)
        ? ProtoCursorPaginatedResponse.fromJSON(object.paginatedData)
        : undefined,
      appliedFilters: isObject(object.appliedFilters)
        ? Object.entries(object.appliedFilters).reduce<{ [key: string]: ProtoFilterValue }>((acc, [key, value]) => {
          acc[key] = ProtoFilterValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ProtoFetchMorePayload): unknown {
    const obj: any = {};
    if (message.paginatedData !== undefined) {
      obj.paginatedData = ProtoCursorPaginatedResponse.toJSON(message.paginatedData);
    }
    if (message.appliedFilters) {
      const entries = Object.entries(message.appliedFilters);
      if (entries.length > 0) {
        obj.appliedFilters = {};
        entries.forEach(([k, v]) => {
          obj.appliedFilters[k] = ProtoFilterValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoFetchMorePayload>, I>>(base?: I): ProtoFetchMorePayload {
    return ProtoFetchMorePayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoFetchMorePayload>, I>>(object: I): ProtoFetchMorePayload {
    const message = createBaseProtoFetchMorePayload();
    message.paginatedData = (object.paginatedData !== undefined && object.paginatedData !== null)
      ? ProtoCursorPaginatedResponse.fromPartial(object.paginatedData)
      : undefined;
    message.appliedFilters = Object.entries(object.appliedFilters ?? {}).reduce<{ [key: string]: ProtoFilterValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ProtoFilterValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseProtoFetchMorePayload_AppliedFiltersEntry(): ProtoFetchMorePayload_AppliedFiltersEntry {
  return { key: "", value: undefined };
}

export const ProtoFetchMorePayload_AppliedFiltersEntry: MessageFns<ProtoFetchMorePayload_AppliedFiltersEntry> = {
  encode(message: ProtoFetchMorePayload_AppliedFiltersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ProtoFilterValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoFetchMorePayload_AppliedFiltersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoFetchMorePayload_AppliedFiltersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ProtoFilterValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoFetchMorePayload_AppliedFiltersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ProtoFilterValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ProtoFetchMorePayload_AppliedFiltersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ProtoFilterValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoFetchMorePayload_AppliedFiltersEntry>, I>>(
    base?: I,
  ): ProtoFetchMorePayload_AppliedFiltersEntry {
    return ProtoFetchMorePayload_AppliedFiltersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoFetchMorePayload_AppliedFiltersEntry>, I>>(
    object: I,
  ): ProtoFetchMorePayload_AppliedFiltersEntry {
    const message = createBaseProtoFetchMorePayload_AppliedFiltersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ProtoFilterValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseProtoFetchResponsePayload(): ProtoFetchResponsePayload {
  return { requestId: "", status: 0, message: undefined, data: undefined };
}

export const ProtoFetchResponsePayload: MessageFns<ProtoFetchResponsePayload> = {
  encode(message: ProtoFetchResponsePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.message !== undefined) {
      writer.uint32(26).string(message.message);
    }
    if (message.data !== undefined) {
      ProtoAny.encode(message.data, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoFetchResponsePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoFetchResponsePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = ProtoAny.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoFetchResponsePayload {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      status: isSet(object.status) ? protoFetchStatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
      data: isSet(object.data) ? ProtoAny.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: ProtoFetchResponsePayload): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.status !== 0) {
      obj.status = protoFetchStatusToJSON(message.status);
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = ProtoAny.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoFetchResponsePayload>, I>>(base?: I): ProtoFetchResponsePayload {
    return ProtoFetchResponsePayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoFetchResponsePayload>, I>>(object: I): ProtoFetchResponsePayload {
    const message = createBaseProtoFetchResponsePayload();
    message.requestId = object.requestId ?? "";
    message.status = object.status ?? 0;
    message.message = object.message ?? undefined;
    message.data = (object.data !== undefined && object.data !== null) ? ProtoAny.fromPartial(object.data) : undefined;
    return message;
  },
};

function createBaseProtoUpdateItem(): ProtoUpdateItem {
  return { id: "", action: 0, data: undefined, version: undefined };
}

export const ProtoUpdateItem: MessageFns<ProtoUpdateItem> = {
  encode(message: ProtoUpdateItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    if (message.data !== undefined) {
      ProtoAny.encode(message.data, writer.uint32(26).fork()).join();
    }
    if (message.version !== undefined) {
      writer.uint32(32).int64(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoUpdateItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoUpdateItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = ProtoAny.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoUpdateItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      action: isSet(object.action) ? protoUpdateItem_ActionFromJSON(object.action) : 0,
      data: isSet(object.data) ? ProtoAny.fromJSON(object.data) : undefined,
      version: isSet(object.version) ? globalThis.Number(object.version) : undefined,
    };
  },

  toJSON(message: ProtoUpdateItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.action !== 0) {
      obj.action = protoUpdateItem_ActionToJSON(message.action);
    }
    if (message.data !== undefined) {
      obj.data = ProtoAny.toJSON(message.data);
    }
    if (message.version !== undefined) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoUpdateItem>, I>>(base?: I): ProtoUpdateItem {
    return ProtoUpdateItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoUpdateItem>, I>>(object: I): ProtoUpdateItem {
    const message = createBaseProtoUpdateItem();
    message.id = object.id ?? "";
    message.action = object.action ?? 0;
    message.data = (object.data !== undefined && object.data !== null) ? ProtoAny.fromPartial(object.data) : undefined;
    message.version = object.version ?? undefined;
    return message;
  },
};

function createBaseProtoUpdatesPayload(): ProtoUpdatesPayload {
  return { items: [], appliedFilters: {} };
}

export const ProtoUpdatesPayload: MessageFns<ProtoUpdatesPayload> = {
  encode(message: ProtoUpdatesPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      ProtoUpdateItem.encode(v!, writer.uint32(10).fork()).join();
    }
    Object.entries(message.appliedFilters).forEach(([key, value]) => {
      ProtoUpdatesPayload_AppliedFiltersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoUpdatesPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoUpdatesPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(ProtoUpdateItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ProtoUpdatesPayload_AppliedFiltersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.appliedFilters[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoUpdatesPayload {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => ProtoUpdateItem.fromJSON(e)) : [],
      appliedFilters: isObject(object.appliedFilters)
        ? Object.entries(object.appliedFilters).reduce<{ [key: string]: ProtoFilterValue }>((acc, [key, value]) => {
          acc[key] = ProtoFilterValue.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ProtoUpdatesPayload): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => ProtoUpdateItem.toJSON(e));
    }
    if (message.appliedFilters) {
      const entries = Object.entries(message.appliedFilters);
      if (entries.length > 0) {
        obj.appliedFilters = {};
        entries.forEach(([k, v]) => {
          obj.appliedFilters[k] = ProtoFilterValue.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoUpdatesPayload>, I>>(base?: I): ProtoUpdatesPayload {
    return ProtoUpdatesPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoUpdatesPayload>, I>>(object: I): ProtoUpdatesPayload {
    const message = createBaseProtoUpdatesPayload();
    message.items = object.items?.map((e) => ProtoUpdateItem.fromPartial(e)) || [];
    message.appliedFilters = Object.entries(object.appliedFilters ?? {}).reduce<{ [key: string]: ProtoFilterValue }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ProtoFilterValue.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseProtoUpdatesPayload_AppliedFiltersEntry(): ProtoUpdatesPayload_AppliedFiltersEntry {
  return { key: "", value: undefined };
}

export const ProtoUpdatesPayload_AppliedFiltersEntry: MessageFns<ProtoUpdatesPayload_AppliedFiltersEntry> = {
  encode(message: ProtoUpdatesPayload_AppliedFiltersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ProtoFilterValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoUpdatesPayload_AppliedFiltersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoUpdatesPayload_AppliedFiltersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ProtoFilterValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoUpdatesPayload_AppliedFiltersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ProtoFilterValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ProtoUpdatesPayload_AppliedFiltersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ProtoFilterValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoUpdatesPayload_AppliedFiltersEntry>, I>>(
    base?: I,
  ): ProtoUpdatesPayload_AppliedFiltersEntry {
    return ProtoUpdatesPayload_AppliedFiltersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoUpdatesPayload_AppliedFiltersEntry>, I>>(
    object: I,
  ): ProtoUpdatesPayload_AppliedFiltersEntry {
    const message = createBaseProtoUpdatesPayload_AppliedFiltersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ProtoFilterValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseProtoRpcPayload(): ProtoRpcPayload {
  return { method: "", status: 0, success: undefined, error: undefined };
}

export const ProtoRpcPayload: MessageFns<ProtoRpcPayload> = {
  encode(message: ProtoRpcPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.success !== undefined) {
      ProtoRpcSuccessPayload.encode(message.success, writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      ProtoRpcErrorPayload.encode(message.error, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoRpcPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoRpcPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.success = ProtoRpcSuccessPayload.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = ProtoRpcErrorPayload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoRpcPayload {
    return {
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      status: isSet(object.status) ? protoRpcStatusFromJSON(object.status) : 0,
      success: isSet(object.success) ? ProtoRpcSuccessPayload.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? ProtoRpcErrorPayload.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ProtoRpcPayload): unknown {
    const obj: any = {};
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.status !== 0) {
      obj.status = protoRpcStatusToJSON(message.status);
    }
    if (message.success !== undefined) {
      obj.success = ProtoRpcSuccessPayload.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = ProtoRpcErrorPayload.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoRpcPayload>, I>>(base?: I): ProtoRpcPayload {
    return ProtoRpcPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoRpcPayload>, I>>(object: I): ProtoRpcPayload {
    const message = createBaseProtoRpcPayload();
    message.method = object.method ?? "";
    message.status = object.status ?? 0;
    message.success = (object.success !== undefined && object.success !== null)
      ? ProtoRpcSuccessPayload.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? ProtoRpcErrorPayload.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseProtoRpcSuccessPayload(): ProtoRpcSuccessPayload {
  return { data: undefined };
}

export const ProtoRpcSuccessPayload: MessageFns<ProtoRpcSuccessPayload> = {
  encode(message: ProtoRpcSuccessPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      ProtoAny.encode(message.data, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoRpcSuccessPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoRpcSuccessPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = ProtoAny.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoRpcSuccessPayload {
    return { data: isSet(object.data) ? ProtoAny.fromJSON(object.data) : undefined };
  },

  toJSON(message: ProtoRpcSuccessPayload): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = ProtoAny.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoRpcSuccessPayload>, I>>(base?: I): ProtoRpcSuccessPayload {
    return ProtoRpcSuccessPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoRpcSuccessPayload>, I>>(object: I): ProtoRpcSuccessPayload {
    const message = createBaseProtoRpcSuccessPayload();
    message.data = (object.data !== undefined && object.data !== null) ? ProtoAny.fromPartial(object.data) : undefined;
    return message;
  },
};

function createBaseProtoRpcErrorPayload(): ProtoRpcErrorPayload {
  return { errorCode: "", errorMessage: undefined, details: undefined };
}

export const ProtoRpcErrorPayload: MessageFns<ProtoRpcErrorPayload> = {
  encode(message: ProtoRpcErrorPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorCode !== "") {
      writer.uint32(10).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.details !== undefined) {
      ProtoStruct.encode(ProtoStruct.wrap(message.details), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtoRpcErrorPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtoRpcErrorPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details = ProtoStruct.unwrap(ProtoStruct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtoRpcErrorPayload {
    return {
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
      details: isObject(object.details) ? object.details : undefined,
    };
  },

  toJSON(message: ProtoRpcErrorPayload): unknown {
    const obj: any = {};
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    if (message.details !== undefined) {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtoRpcErrorPayload>, I>>(base?: I): ProtoRpcErrorPayload {
    return ProtoRpcErrorPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtoRpcErrorPayload>, I>>(object: I): ProtoRpcErrorPayload {
    const message = createBaseProtoRpcErrorPayload();
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? undefined;
    message.details = object.details ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
