/**
 * SCRIPT PURPOSE:
 * The "Danger Zone Profiler" is a post-processing tool designed to analyze grouped event data
 * from rug/profit simulations. It identifies the "Horizon" (the earliest detection point)
 * for every crash or win, calculating critical metrics like lead time, detection intensity,
 * and index span. This data is essential for studying pre-rug conditions and optimizing
 * exit strategy latency across large datasets (90k+ coins).
 */

import fs from 'fs';

import { Command } from 'commander';
import { z } from 'zod';

import { logger } from '@src/logger';
import { AnalyzeMintResultsOutput } from '@src/scripts/pumpfun/analyze-mint-results';

// --- TYPES ---

/**
 * Detailed profile of a unique market event (Rug or Profit peak).
 * Aggregated from multiple trigger points to identify the "Horizon."
 */
export type EventProfile = {
    /** The exact unix timestamp (ms) when the exit condition (crash or target) was reached. */
    timestamp: number;

    /** 'RUG' for a detected crash, 'WIN' for a detected profit target reached. */
    mode: 'RUG' | 'WIN';

    /** * The FIRST index in the history array that flagged this event.
     * This is the "Horizon"—the earliest moment your algorithm detected the upcoming move.
     */
    horizonIndex: number;

    /** * The duration in milliseconds from the first detection (at horizonIndex) until the event completed.
     * Use this to measure your "Exit Window." If this is < 500ms, you likely cannot exit in time.
     */
    leadTimeMs: number;

    /** * Total number of ticks/indices that flagged this same event.
     * High intensity (> 10) means a slow, predictable trend.
     * Low intensity (1-2) means a "Flash" event or instant liquidity pull.
     */
    intensity: number;

    /** * The distance in the history array between the first and last trigger for this event.
     * High span indicates the event was "visible" to the bot for a large number of ticks.
     */
    indexSpan: number;

    /** * The percentage price change at the moment the event was finalized.
     * For RUG: Usually a large negative (e.g., -90).
     * For WIN: Your target profit percentage.
     */
    finalDelta: number;
};

export type DangerZoneProfileResult = Record<string, EventProfile[]>;

// --- CONFIGURATION SCHEMA ---

const profilerConfigSchema = z.object({
    reportPath: z.string().describe('Path to the JSON report generated by analyze-mint-results'),
    exportSummaryOnly: z
        .boolean()
        .optional()
        .default(false)
        .describe('If true, only logs high-level summaries per file'),
});

type ProfilerConfig = z.infer<typeof profilerConfigSchema>;

// --- CLI ---

const command = new Command();
command
    .name('profile-danger-zones')
    .description('Aggregates grouped events to identify "Horizon" windows for rug/profit study.')
    .version('1.0.1')
    .requiredOption('--config <string>', 'path to a profiler config file or inline JSON')
    .action(async args => {
        let configRaw: string;
        const input = args.config.trim();

        if (input.startsWith('{')) {
            configRaw = input;
        } else {
            configRaw = fs.readFileSync(input, 'utf-8');
        }

        try {
            const config = profilerConfigSchema.parse(JSON.parse(configRaw));
            await profileDangerZones(config);
        } catch (err) {
            logger.error('Failed to parse config: %s', err instanceof Error ? err.message : String(err));
            process.exit(1);
        }
    });

if (require.main === module) {
    command.parse(process.argv);
}

// --- MAIN LOGIC ---

/**
 * Processes grouped analysis results to extract high-level event signatures.
 * @returns A record of file paths mapped to their identified event profiles.
 */
export async function profileDangerZones(config: ProfilerConfig): Promise<DangerZoneProfileResult> {
    const report: AnalyzeMintResultsOutput = JSON.parse(fs.readFileSync(config.reportPath, 'utf-8'));
    const findings: DangerZoneProfileResult = {};

    logger.info('=== Starting Danger Zone Profiling ===');
    logger.info('Source Report: %s', config.reportPath);
    logger.info('Files Processed in Report: %d', report.processed);
    logger.info('--------------------------------------------------');

    const fileEntries = Object.entries(report.events);

    if (fileEntries.length === 0) {
        logger.warn('No grouped events found in the provided report.');
        return findings;
    }

    for (const [filePath, eventsByTimestamp] of fileEntries) {
        const uniqueEventCount = Object.keys(eventsByTimestamp).length;
        logger.info('FILE: %s (%d unique crash/profit events)', filePath, uniqueEventCount);

        findings[filePath] = [];

        for (const [timestamp, triggers] of Object.entries(eventsByTimestamp)) {
            // Sort triggers by index to find the earliest point of detection (The Horizon)
            const sortedTriggers = triggers.sort((a, b) => a.triggerIndex - b.triggerIndex);

            const earliest = sortedTriggers[0];
            const latest = sortedTriggers[sortedTriggers.length - 1];
            const mode = earliest.data.type as 'RUG' | 'WIN';

            // Calculate the lead time (Horizon to Impact)
            const timeDiffMs = Number(timestamp) - earliest.data.startTimestamp;
            const triggerSpan = latest.triggerIndex - earliest.triggerIndex;

            // Store findings
            findings[filePath].push({
                timestamp: Number(timestamp),
                mode,
                horizonIndex: earliest.triggerIndex,
                leadTimeMs: timeDiffMs,
                intensity: triggers.length,
                indexSpan: triggerSpan,
                finalDelta: earliest.data.endingPriceDiffPercentage,
            });

            if (config.exportSummaryOnly) continue;

            logger.info('  [EVENT @ %s] Type: %s', timestamp, mode);

            if (mode === 'RUG') {
                logger.info('  ├── Horizon Index (Earliest Warning): %d', earliest.triggerIndex);
                logger.info('  ├── Exit Window (Time to Impact):   %dms', timeDiffMs);
            } else {
                logger.info('  ├── Ideal Entry Index:              %d', earliest.triggerIndex);
                logger.info('  ├── Maturity Time (Time to Profit): %dms', timeDiffMs);
            }

            logger.info('  ├── Intensity:                      %d ticks flagged this event', triggers.length);
            logger.info('  ├── Detection Span:                 %d indices', triggerSpan);
            logger.info(
                '  └── Final Delta:                    %s%%',
                earliest.data.endingPriceDiffPercentage.toFixed(2),
            );

            // Logic Insight: High density suggests a predictable trend; low density suggests a flash event.
            if (triggers.length > 8) {
                logger.debug('  [Context] High trigger density for event %s suggests a sustained movement.', timestamp);
            }
        }
    }

    logger.info('--------------------------------------------------');
    logger.info('Profiling Complete.');

    return findings;
}
