import { z } from 'zod';

import { Backtest } from '@src/db/types';
import { ProtoBacktestRun } from '@src/protos/generated/backtests';
import { loggerTypeSchema, strategyFileConfigSchema } from '@src/trading/config/types';
import { upgradeToRangeAware } from '@src/utils/zod/upgradeToRangeAware';

import { BacktestConfig, backtestConfigSchema } from '../bots/blockchains/solana/types';
import LaunchpadBotStrategy from '../strategies/launchpads/LaunchpadBotStrategy';

const runStrategyLoggingSchema = z.object({
    level: z.enum(['none', 'info', 'verbose']).optional(),
    includeTrades: z.boolean().optional(),
    /** * How often to log periodic status (e.g., 100 = every 100th mint).
     * 0 = Disable periodic logs (Only log critical events like 'Out of Balance').
     */
    logInterval: z.number().int().min(0).optional(),
});
export type RunStrategyLoggingConfig = z.infer<typeof runStrategyLoggingSchema>;

const backtestRunBaseConfigSchema = z.object({
    strategyLogger: loggerTypeSchema.optional(),
    strategies: z.array(strategyFileConfigSchema),
    logging: z
        .object({
            runStrategy: runStrategyLoggingSchema.optional(),
        })
        .optional(),
    storage: z
        .object({
            /** * 'all': Store every result.
             * 'best_only': Only update the DB if the current metric is higher than previous champions.
             */
            strategyPersistence: z.enum(['all', 'best_only']).default('all'),

            /** Toggle for detailed per-mint data */
            storeMintResults: z.boolean().optional(),
        })
        .optional(),
    /** * RUNTIME STATE:
     * This block is usually generated by the system during a run
     * and fed back in to resume an interrupted process.
     */
    checkpoint: z
        .object({
            /**
             * The global count of all permutations tested across the entire backtest run.
             * Used for overall progress bars and ETA calculations (e.g., 50,000 of 1,000,000).
             */
            lastIterationIndex: z.number().nonnegative(),

            /**
             * The specific index of the strategy currently being processed.
             * Represents progress through the strategies list (e.g., Strategy 5 of 100).
             */
            lastStrategyIndex: z.number().nonnegative(),

            /**
             * The index of the specific permutation/variant within the current strategy.
             * Used to resume deep within a large permutation set (e.g., variant 500 of 2000).
             */
            lastPermutationIterationIndex: z.number().nonnegative().optional(),

            /**
             * A unique hash or ID of the specific configuration variant.
             * Acts as a safety check to ensure we are resuming the exact same parameter set.
             */
            lastPermutationId: z.string().optional(),

            /**
             *  Re-hydrates the "Champions" leaderboard.
             * Mapping: { [MetricName]: { id: DB_ID, score: LAST_BEST_SCORE } }
             */
            champions: z
                .record(
                    z.string(), // RankingMetric (e.g., 'roi', 'winRate')
                    z.object({
                        id: z.number(),
                        // This holds the partial 'sr' `StrategyBacktestResult` object: { roi: 1.2, winRate: 0.8, ... }
                        state: z.object({
                            totalRoi: z.number().positive().max(100),
                            winRatePercentage: z.number().positive().max(100),
                        }),
                    }),
                )
                .optional(),
        })
        .optional(),
    pubsub: z
        .object({
            /** Broadcast high-level backtest run creation/completion/updates */
            notifyRunUpdate: z.boolean().default(true),

            /** Broadcast high-level strategy creation/completion/updates */
            notifyStrategyUpdate: z.boolean().default(true),

            /** * Broadcast individual mint completions.
             * Warning: High frequency can flood WebSockets.
             */
            notifyMintResults: z.boolean().default(false),
        })
        .optional(),
});
export type BacktestRunCheckpoint = NonNullable<BacktestRunBaseConfig['checkpoint']>;
export type BacktestRunBaseConfig = z.infer<typeof backtestRunBaseConfigSchema>;

export const backtestRunConfigSchema = backtestRunBaseConfigSchema.and(
    z.union([
        z.object({
            backtestId: z.string(),
        }),
        z.object({
            config: backtestConfigSchema,
        }),
    ]),
);
export type BacktestRunConfig = z.infer<typeof backtestRunConfigSchema>;

export const rangeAwareBacktestRunConfigSchema = upgradeToRangeAware(backtestRunConfigSchema);

export type StrategyPermutationSet = {
    generator: Generator<LaunchpadBotStrategy>;
    permutationsCount: number;
};

export type StrategyExecutionItem = LaunchpadBotStrategy | StrategyPermutationSet;

/**
 * Type Guard to narrow down a strategy item to a permutation set.
 */
export function isStrategyPermutation(item: StrategyExecutionItem): item is StrategyPermutationSet {
    return item !== null && typeof item === 'object' && 'generator' in item && 'permutationsCount' in item;
}

type RunBacktestCommonParams = Omit<BacktestRunBaseConfig, 'strategyLogger' | 'strategies'> & {
    strategies: StrategyExecutionItem[];
};

export type RunBacktestFromRunConfigParams = RunBacktestCommonParams & {
    backtestRun: ProtoBacktestRun;
    backtest: Backtest;
};

export type RunBacktestParams =
    | ((
          | {
                backtest: Backtest;
            }
          | {
                backtestConfig: BacktestConfig;
            }
      ) &
          RunBacktestCommonParams)
    | RunBacktestFromRunConfigParams;
